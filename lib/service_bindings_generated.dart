// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:async';
import 'dart:ffi' as ffi;
import 'dart:isolate';
import 'package:ffi/ffi.dart';

import 'result_struct.dart';

/// Bindings for `src/service.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class ServiceBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ServiceBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ServiceBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  //DART_EXPORT intptr_t Dart_InitializeApiDL(void* data);
  // Dart_InitializeApiDL defined in Dart SDK (dart_api_dl.c)
  late final _Dart_InitializeApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          "Dart_InitializeApiDL");

  late final _Dart_InitializeApiDL = _Dart_InitializeApiDLPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>)>();

  ///
  /// start service function
  ///
  late final _startServicePtr = _lookup<
      ffi.NativeFunction<
          ResultStruct Function(
              ffi.Int64, ffi.Pointer<Utf16>)>>("service_start_service");
  late final _startService = _startServicePtr
      .asFunction<ResultStruct Function(int, ffi.Pointer<Utf16>)>();
  int? cookie;
  final StreamController<String> _servecCtrl = StreamController();
  Stream<String> get serviceStream => _servecCtrl.stream;

   startService(String serviceName) {
    if (cookie != null) {
      return false;
    }
    // Call Dart_InitializeApiDL with NativeApi.initializeApiDLData

    cookie = _Dart_InitializeApiDL(ffi.NativeApi.initializeApiDLData);
    final pub = ReceivePort()
      ..listen((message) async {
        _servecCtrl.add(message);
      });

    // Pass NativePort value (int) to C++ code
    final result =
        _startService(pub.sendPort.nativePort, serviceName.toNativeUtf16());

    if (!result.status) throw result.exception;
  }

  ///
  /// install service function
  ///
  late final _installServicePtr = _lookup<
      ffi.NativeFunction<
          ResultStruct Function(ffi.Pointer<Utf16>, ffi.Pointer<Utf16>,
              ffi.Pointer<Utf16>)>>("service_install_service");
  late final _installService = _installServicePtr.asFunction<
      ResultStruct Function(
          ffi.Pointer<Utf16>, ffi.Pointer<Utf16>, ffi.Pointer<Utf16>)>();
  installService(
      String serviceName, String serviceDisplayName, String appPath) {
    final result = _installService(
      serviceName.toNativeUtf16(),
      serviceDisplayName.toNativeUtf16(),
      appPath.toNativeUtf16(),
    );
    if (!result.status) throw result.exception;
  }
}


// FFI_PLUGIN_EXPORT intptr_t service_start_service(Dart_Port_DL port, wchar_t serviceName)
// {
//   // Dart_CObject msg;
//   //   msg.type = Dart_CObject_kString;
//   //   msg.value.as_string = (char *)" hello from c to dart";

//   //   // The function is thread-safe; you can call it anywhere on your C++ code
//   //   Dart_PostCObject_DL(port, &msg);
//   return start_service(port, serviceName);
// }

// FFI_PLUGIN_EXPORT intptr_t service_install_service(wchar_t serviceName, wchar_t serviceDisplayName, wchar_t appPath)
// {

//   return install_service(serviceName, serviceDisplayName, appPath);
// }
